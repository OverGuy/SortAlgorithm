###### 核心思想：
1，将数组中第一个元素看成一个有序数组，遍历数组中其余无序的元素，将其插入到有序数组部分中。
2，无序元素插入到有序数组中的过程，从当前无序元素往前遍历有序数组，如果如果前一个元素大于当前元素，则交换值，反之则退出循环，当前的插入操作结束。
理论上插入排序比选择排序效率更高，因为插入排序嵌套循环中的里循环有退出循环的条件，而选择排序没有。
<br>
时间复杂度O(n^2)
<br>
```Java
	public static void insertionSort(int[] arr){
		int length = arr.length;
		for(int i = 1; i < length; i ++){
			for(int j = i; j > 0; j --){
				if(arr[j - 1] > arr[j]){
					int temp = arr[j - 1];
					arr[j - 1] = arr[j];
					arr[j] = temp;
				}else{
					break;
				}
			}
		}
	}
```

###### 优化
上述代码中，内层循环插入操作中需要进行多次的元素值交换，每次交换需要三次赋值，还需要多次通过数组下标去访问数组元素值的操作。所以对代码进行优化，只进行一次值的交换。

```Java
	public static void insertionSort(int[] arr){
		int length = arr.length;
		for(int i = 1; i < length; i ++){
			int e = arr[i];
			int j = i;
			for( ; j > 0 && arr[j - 1] > e; j --){
				arr[j] = arr[j - 1];
			}
			arr[j] = e;
		}
	}
```

###### 优点总结
对于一个近乎有序的数组进行排序时，插入排序的效率非常高。要远远的高于选择排序，甚至比高级排序算法（O(nlogn)）的效率更高。
<br>
这也是为什么插入排序是有非常重要的实际意义的，因为很多时候我们处理的真实数据就是近乎有序的，比如说一套系统的日志，道理上就是按照时间顺序去生成的，但有可能在中间产生一些错误，或者是某一些任务时间过长，所以存在几个无序的元素。那么对于这样的一个系统日志，我们使用插入排序的话性能会更好。
<br>
我们通过代码可以分析一下，在最优的情况下，当我们需要排序的数组是一个完全有序的数组，插入排序将变成一个O(n)级别的算法，因为内层循环每次都只执行一下，发现就是合适的位置，结束了内存循环，外层循环进入下次循环。所以当一个近乎有序的数组用插入排序法进行排序时，这时候的时间复杂度会比较接近O(n)。这是插入排序非常重要的一个性质。
<br>
真是因为这个原因，插入排序也会在更加复杂的排序算法中，作为一个子过程来进行优化。
